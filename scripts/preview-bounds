#!/usr/bin/env ruby

# prints two values in milliseconds for the start and end of a song preview.
# these are determined by preview_start and preview_end events in the midi.
# if preview_start is omitted, it defaults to 0.
# if preview_end is omitted, it defaults to 30 seconds after the start.
# some small amount is subtracted from the preview_start so you can actually
# hear the point at which the preview_start event is placed.

def print_usage
  STDERR.puts "Usage: #{$0} notes.mid [start|both]"
  exit 1
end
print_usage unless (1..2).include?(ARGV.length)
mid, mode = ARGV
mode ||= 'both'
case mode
when 'start'
  compute_end = false
when 'both'
  compute_end = true
else
  STDERR.puts "Unrecognized mode #{mode}"
  print_usage
end

starts = `"#{File.dirname(__FILE__)}/find-text" "preview_start" #{mid}`
starts = starts.strip.split(/\s+/)
if compute_end
  ends = `"#{File.dirname(__FILE__)}/find-text" "preview_end" #{mid}`
  ends = ends.strip.split(/\s+/)
end

if starts.empty?
  pstart = `"#{File.dirname(__FILE__)}/find-text" "[prc_chorus_1]" #{mid}`.to_f
  if pstart == 0
    pstart = `"#{File.dirname(__FILE__)}/find-text" "[prc_chorus]" #{mid}`.to_f
  end
else
  puts "Warning: multiple preview_start events found" if starts.length > 1
  pstart = starts[0].to_f
end

if compute_end
  if ends.empty?
    pend = pstart + 30
  else
    puts "Warning: multiple preview_end events found" if ends.length > 1
    pend = ends[0].to_f
  end
end

pstart = [0, pstart - 0.6].max
pstart = (pstart * 1000).floor
if compute_end
  pend = (pend * 1000).floor
  puts "#{pstart} #{pend}"
else
  puts "#{pstart}"
end
