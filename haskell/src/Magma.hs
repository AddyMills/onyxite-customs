module Magma (runMagmaMIDI, runMagma, runMagmaV1, getRBAFile, getRBAFileBS) where

import           Control.Monad                  (forM_, replicateM)
import           Control.Monad.IO.Class         (MonadIO (liftIO))
import           Control.Monad.Trans.Resource   (MonadResource)
import           Control.Monad.Trans.StackTrace
import           Data.Binary.Get                (getWord32le, runGet)
import qualified Data.ByteString.Lazy           as BL
import           Resources                      (magmaCommonDir, magmaV1Dir,
                                                 magmaV2Dir)
import qualified System.Directory               as Dir
import           System.FilePath                ((</>))
import           System.Info                    (os)
import qualified System.IO                      as IO
import           System.Process

withWin32Exe :: (FilePath -> [String] -> a) -> FilePath -> [String] -> a
withWin32Exe f exe args = if os == "mingw32"
  then f exe args
  else f "wine" $ exe : args

-- | modified from <https://stackoverflow.com/q/6807025>
copyDirContents :: FilePath -> FilePath -> IO ()
copyDirContents src dst = do
  Dir.createDirectoryIfMissing False dst
  xs <- Dir.listDirectory src
  forM_ xs $ \name -> do
    let srcPath = src </> name
    let dstPath = dst </> name
    isDirectory <- Dir.doesDirectoryExist srcPath
    if isDirectory
      then copyDirContents srcPath dstPath
      else Dir.copyFile srcPath dstPath

-- | Runs the MIDI export process. Note that this process will always overwrite
-- the animations and venue with autogenerated versions, which is different from
-- the normal RBA compiler (which only autogenerates them if missing).
runMagmaMIDI :: (MonadResource m) => FilePath -> FilePath -> StackTraceT m String
runMagmaMIDI proj mid = tempDir "magma" $ \tmp -> do
  wd <- liftIO Dir.getCurrentDirectory
  let proj' = wd </> proj
      mid'  = wd </> mid
  liftIO $ forM_ [magmaV2Dir, magmaCommonDir] (>>= \dir -> copyDirContents dir tmp)
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompilerC3.exe") ["-export_midi", proj', mid']
  inside "running Magma v2 to export MIDI" $ stackProcess createProc

runMagma :: (MonadResource m) => FilePath -> FilePath -> StackTraceT m String
runMagma proj rba = tempDir "magma" $ \tmp -> do
  wd <- liftIO Dir.getCurrentDirectory
  let proj' = wd </> proj
      rba'  = wd </> rba
  liftIO $ forM_ [magmaV2Dir, magmaCommonDir] (>>= \dir -> copyDirContents dir tmp)
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompilerC3.exe") [proj', rba']
  inside "running Magma v2" $ stackProcess createProc

runMagmaV1 :: (MonadResource m) => FilePath -> FilePath -> StackTraceT m String
runMagmaV1 proj rba = tempDir "magma-v1" $ \tmp -> do
  wd <- liftIO Dir.getCurrentDirectory
  let proj' = wd </> proj
      rba'  = wd </> rba
  liftIO $ forM_ [magmaV1Dir, magmaCommonDir] (>>= \dir -> copyDirContents dir tmp)
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompiler.exe") [proj', rba']
  inside "running Magma v1" $ stackProcess createProc

getRBAFileBS :: (MonadIO m) => Int -> FilePath -> m BL.ByteString
getRBAFileBS i rba = liftIO $ IO.withBinaryFile rba IO.ReadMode $ \h -> do
  IO.hSeek h IO.AbsoluteSeek 0x08
  let read7words = runGet (replicateM 7 getWord32le) <$> BL.hGet h (7 * 4)
  offsets <- read7words
  sizes <- read7words
  IO.hSeek h IO.AbsoluteSeek $ fromIntegral $ offsets !! i
  BL.hGet h $ fromIntegral $ sizes !! i

getRBAFile :: (MonadIO m) => Int -> FilePath -> FilePath -> m ()
getRBAFile i rba out = getRBAFileBS i rba >>= liftIO . BL.writeFile out
