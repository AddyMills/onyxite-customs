module Magma (runMagmaMIDI, runMagma, runMagmaV1, oggToMogg) where

import           Control.Monad                  (forM_)
import           Control.Monad.IO.Class         (MonadIO (liftIO))
import           Control.Monad.Trans.Resource   (ResourceT, runResourceT)
import           Control.Monad.Trans.StackTrace
import           Data.Bits                      (shiftL)
import qualified Data.ByteString                as B
import           Data.Conduit.Audio             (AudioSource, Duration (..),
                                                 silent)
import           Data.Conduit.Audio.Sndfile     (sinkSnd)
import           Data.Int                       (Int16)
import           Data.Word                      (Word32)
import           Resources                      (magmaFiles, magmaV1Files)
import qualified Sound.File.Sndfile             as Snd
import qualified System.Directory               as Dir
import           System.FilePath                ((</>))
import           System.Info                    (os)
import qualified System.IO                      as IO
import           System.Process

withWin32Exe :: (FilePath -> [String] -> a) -> FilePath -> [String] -> a
withWin32Exe f exe args = if os == "mingw32"
  then f exe args
  else f "wine" $ exe : args

-- | Runs the MIDI export process. Note that this process will always overwrite
-- the animations and venue with autogenerated versions, which is different from
-- the normal RBA compiler (which only autogenerates them if missing).
runMagmaMIDI :: (MonadIO m) => FilePath -> FilePath -> StackTraceT m String
runMagmaMIDI proj mid = tempDir "magma" $ \tmp -> do
  wd <- liftIO Dir.getCurrentDirectory
  let proj' = wd </> proj
      mid'  = wd </> mid
  liftIO $ Dir.createDirectory $ tmp </> "gen"
  liftIO $ forM_ magmaFiles $ \(path, bs) -> B.writeFile (tmp </> path) bs
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompilerC3.exe") ["-export_midi", proj', mid']
  inside "running Magma v2 to export MIDI" $ stackProcess createProc ""

runMagma :: (MonadIO m) => FilePath -> FilePath -> StackTraceT m String
runMagma proj rba = tempDir "magma" $ \tmp -> do
  wd <- liftIO Dir.getCurrentDirectory
  let proj' = wd </> proj
      rba'  = wd </> rba
  liftIO $ Dir.createDirectory $ tmp </> "gen"
  liftIO $ forM_ magmaFiles $ \(path, bs) -> B.writeFile (tmp </> path) bs
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompilerC3.exe") [proj', rba']
  inside "running Magma v2" $ stackProcess createProc ""

runMagmaV1 :: (MonadIO m) => FilePath -> FilePath -> StackTraceT m String
runMagmaV1 proj rba = tempDir "magma-v1" $ \tmp -> do
  wd <- liftIO Dir.getCurrentDirectory
  let proj' = wd </> proj
      rba'  = wd </> rba
  liftIO $ Dir.createDirectory $ tmp </> "gen"
  liftIO $ Dir.createDirectory $ tmp </> "facefx"
  liftIO $ forM_ magmaV1Files $ \(path, bs) -> B.writeFile (tmp </> path) bs
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompiler.exe") [proj', rba']
  inside "running Magma v1" $ stackProcess createProc ""

oggToMogg :: (MonadIO m) => FilePath -> FilePath -> StackTraceT m ()
oggToMogg ogg mogg = tempDir "ogg2mogg" $ \tmp -> do
  wd <- liftIO $ Dir.getCurrentDirectory
  let ogg'  = wd </> ogg
      mogg' = wd </> mogg
  liftIO $ Dir.createDirectory $ tmp </> "gen"
  liftIO $ forM_ magmaFiles $ \(path, bs) -> B.writeFile (tmp </> path) bs
  liftIO $ Dir.renameFile (tmp </> "oggenc-redirect.exe") (tmp </> "oggenc.exe")
  liftIO $ Dir.copyFile ogg' $ tmp </> "audio.ogg"
  let proj = "hellskitchen.rbproj"
      rba = "out.rba"
  liftIO $ runResourceT
    $ sinkSnd (tmp </> "silence.wav")
    (Snd.Format Snd.HeaderFormatWav Snd.SampleFormatPcm16 Snd.EndianFile)
    (silent (Seconds 31) 44100 2 :: AudioSource (ResourceT IO) Int16)
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompilerC3.exe") [proj, rba]
  _ <- inside "running Magma v2 to convert OGG to MOGG" $ stackProcess createProc ""
  liftIO $ IO.withBinaryFile (tmp </> rba) IO.ReadMode $ \hrba -> do
    IO.hSeek hrba IO.AbsoluteSeek $ 4 + (4 * 3)
    moggOffset <- hReadWord32le hrba
    IO.hSeek hrba IO.AbsoluteSeek $ 4 + (4 * 10)
    moggLength <- hReadWord32le hrba
    IO.hSeek hrba IO.AbsoluteSeek $ fromIntegral moggOffset
    moggData <- B.hGet hrba $ fromIntegral moggLength
    B.writeFile mogg' moggData

hReadWord32le :: IO.Handle -> IO Word32
hReadWord32le h = do
  [a, b, c, d] <- map fromIntegral . B.unpack <$> B.hGet h 4
  return $ a + (b `shiftL` 8) + (c `shiftL` 16) + (d `shiftL` 24)
