module Magma (runMagmaMIDI, runMagma, runMagmaV1, oggToMogg, getRBAFile) where

import           Codec.Picture                  (writeBitmap)
import           Control.Monad                  (forM_, replicateM)
import           Control.Monad.IO.Class         (MonadIO (liftIO))
import           Control.Monad.Trans.Resource   (ResourceT, runResourceT)
import           Control.Monad.Trans.StackTrace
import           Data.Binary.Get                (getWord32le, runGet)
import qualified Data.ByteString.Lazy           as BL
import           Data.Conduit.Audio             (AudioSource, Duration (..),
                                                 silent)
import           Data.Conduit.Audio.Sndfile     (sinkSnd)
import           Data.Int                       (Int16)
import           Resources                      (magmaCommonDir,
                                                 magmaOgg2MoggDir, magmaV1Dir,
                                                 magmaV2Dir, onyxAlbum)
import qualified Sound.File.Sndfile             as Snd
import qualified System.Directory               as Dir
import           System.FilePath                ((</>))
import           System.Info                    (os)
import qualified System.IO                      as IO
import           System.Process

withWin32Exe :: (FilePath -> [String] -> a) -> FilePath -> [String] -> a
withWin32Exe f exe args = if os == "mingw32"
  then f exe args
  else f "wine" $ exe : args

-- modified from https://stackoverflow.com/q/6807025
copyDirContents :: FilePath -> FilePath -> IO ()
copyDirContents src dst = do
  Dir.createDirectoryIfMissing False dst
  xs <- Dir.listDirectory src
  forM_ xs $ \name -> do
    let srcPath = src </> name
    let dstPath = dst </> name
    isDirectory <- Dir.doesDirectoryExist srcPath
    if isDirectory
      then copyDirContents srcPath dstPath
      else Dir.copyFile srcPath dstPath

-- | Runs the MIDI export process. Note that this process will always overwrite
-- the animations and venue with autogenerated versions, which is different from
-- the normal RBA compiler (which only autogenerates them if missing).
runMagmaMIDI :: (MonadIO m) => FilePath -> FilePath -> StackTraceT (QueueLog m) String
runMagmaMIDI proj mid = tempDir "magma" $ \tmp -> do
  wd <- liftIO Dir.getCurrentDirectory
  let proj' = wd </> proj
      mid'  = wd </> mid
  liftIO $ forM_ [magmaV2Dir, magmaCommonDir] (>>= \dir -> copyDirContents dir tmp)
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompilerC3.exe") ["-export_midi", proj', mid']
  inside "running Magma v2 to export MIDI" $ stackProcess createProc

runMagma :: (MonadIO m) => FilePath -> FilePath -> StackTraceT (QueueLog m) String
runMagma proj rba = tempDir "magma" $ \tmp -> do
  wd <- liftIO Dir.getCurrentDirectory
  let proj' = wd </> proj
      rba'  = wd </> rba
  liftIO $ forM_ [magmaV2Dir, magmaCommonDir] (>>= \dir -> copyDirContents dir tmp)
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompilerC3.exe") [proj', rba']
  inside "running Magma v2" $ stackProcess createProc

runMagmaV1 :: (MonadIO m) => FilePath -> FilePath -> StackTraceT (QueueLog m) String
runMagmaV1 proj rba = tempDir "magma-v1" $ \tmp -> do
  wd <- liftIO Dir.getCurrentDirectory
  let proj' = wd </> proj
      rba'  = wd </> rba
  liftIO $ forM_ [magmaV1Dir, magmaCommonDir] (>>= \dir -> copyDirContents dir tmp)
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompiler.exe") [proj', rba']
  inside "running Magma v1" $ stackProcess createProc

getRBAFile :: (MonadIO m) => Int -> FilePath -> FilePath -> m ()
getRBAFile i rba out = liftIO $ IO.withBinaryFile rba IO.ReadMode $ \h -> do
  IO.hSeek h IO.AbsoluteSeek 0x08
  let read7words = runGet (replicateM 7 getWord32le) <$> BL.hGet h (7 * 4)
  offsets <- read7words
  sizes <- read7words
  IO.hSeek h IO.AbsoluteSeek $ fromIntegral $ offsets !! i
  BL.hGet h (fromIntegral $ sizes !! i) >>= BL.writeFile out

oggToMogg :: (MonadIO m) => FilePath -> FilePath -> StackTraceT (QueueLog m) ()
oggToMogg ogg mogg = tempDir "ogg2mogg" $ \tmp -> do
  wd <- liftIO Dir.getCurrentDirectory
  let ogg'  = wd </> ogg
      mogg' = wd </> mogg
  liftIO $ forM_ [magmaV2Dir, magmaCommonDir, magmaOgg2MoggDir] (>>= \dir -> copyDirContents dir tmp)
  liftIO $ Dir.copyFile ogg' $ tmp </> "audio.ogg"
  let proj = "ogg2mogg.rbproj"
      rba = "out.rba"
  liftIO $ runResourceT $ sinkSnd (tmp </> "silence.wav")
    (Snd.Format Snd.HeaderFormatWav Snd.SampleFormatPcm16 Snd.EndianFile)
    (silent (Seconds 31) 44100 2 :: AudioSource (ResourceT IO) Int16)
  liftIO $ writeBitmap (tmp </> "cover.bmp") onyxAlbum
  let createProc = withWin32Exe (\exe args -> (proc exe args) { cwd = Just tmp })
        (tmp </> "MagmaCompilerC3.exe") [proj, rba]
  _ <- inside "running Magma v2 to convert OGG to MOGG" $ stackProcess createProc
  getRBAFile 2 (tmp </> rba) mogg'
